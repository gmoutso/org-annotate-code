* Description
~org-annotate-code~ allows you to annotate files that are stored in a separate annotation org-mode file. The annotations are in a two-level or a three-level hierarchy, according to whether there is a top-level heading set or not. Subsequently, the first level describes the file from which the annotation comes from and the second level describes the relevant section in the file that is annotated. The annotation can be made using a capture template with the function ~org-annotate-code-capture-finding-location~ or with the command ~org-annotate-code-create~.

If you just want to just want to visit the relevant location in the annotation file without creating the levels when they do not exist, then there are two functions: ~org-annotate-code-visit-file~ and ~org-annotate-code-visit-org-file~. The first will only create the first level if it does not exist, the level that describes the file. The second command does not create any levels, not even if a top-level heading is set but does not exist, but will always visit the outer-most level that exists that may be just the annotation file.

* Details
The top-level heading is set by ~org-annotate-code-heading0~ and is ~nil~ by default. The annotation file is set by ~org-annotation-code-org-file~. How the two-level hierarchy is created can be customized per major-mode of the annotated file.

The two-level hierarchy is created with custom id properties that link back to the annotated file. Once created, the custom id links should not be changed but the two-level headings can be changed as the identification is always by the custom ids. You can then visit the annotated file or section by ~C-c C-o~ while on the heading. A three-level hierarchy is only used when ~org-annotate-code-heading0~ is set. When set, the top-level heading should not change as this level is identified by a fuzzy search on this heading. 

Not only can the two-level headings change, but the whole two-level or three-level hierarchy can be moved and/or demoted somewhere else in the file. The package will always find it as long as the tree ~[higher heading/.../](top-level heading if set/)(first level id)/(second level id)[/lower headings]~ is somewhere in the annotation file. A level within the two-level or three-level hierarchy should not be placed outside its structure, as the search to identify the nodes is done incrementally by level depth. This structure and search is useful because although the original headings are automatically inserted when first created by the annotation functions, later on a better heading description or placement of the structure might be decided.

What is inserted as custom id links and the original headings is customizable per major-mode of the annotated file. Typically, the first level heading is the file name and the id link is to the file itself. For ~python-mode~, the second level heading is the name of the function, class or global variable definition, which is located either at point or at the nearest upper block. For ~python-mode~ again, the second level custom id link is a search in the file such as a search for ~def func(~ or ~variable =~. For other modes, the second level heading can be the symbol at point and the id link the line number at point. In order to customize, one defines a function such as ~org-annotate-code-info-at-point-generic~ that returns a plist of annotation metadata, and adds this function into the alist ~org-annotate-code-info-alist~ that associates major-modes to such functions.

* Similar Packages
This section was true at the time of writing (2020-06-24). I can amend or add upon request.

~org-annotate-file~ is similar, but ~org-annotate-code~ allows more configuration
 - the links are in custom id properties instead of the headings
 - headings can change at will
 - a function for org-mode capture is provided
 - one can customize the annotation metadata per major-mode
 - the level two heading that describes the section in file is meant to be used always by default in this package
If one does not want to use a second level in the two-level hierarchy, one could restrict to the two functions only: ~org-annotate-code-visit-file~ and ~org-annotate-code-visit-org-file~. The first function always creates the first level when it does not exist, whereas it does not even consider the second level. The second function never creates any levels anyway, so if the second level does not exist it will not influence its function.

~annotation-mode~ is a useful package that annotates non-destructively files. These annotations are not saved in org-mode, but are loaded globally per session from a storage file. It has some very useful features, eg.
 - the annotated words or sentences are highlighted and the annotations are shown below as overlays in the annotated file
 - the annotations are identified by exact positions that are updated live when text is changed in the annotated file. This is to be constrasted to this package that identifies annotations with searches or line numbers that are not updated
 - only if the annotated file was changed when the file was not loaded (I think of ~git pull~) or ~annotation-mode~ was not loaded when changes are made, are the annotation positions identified with a nearby search.
Personally, I use ~annotation-mode~ to comment symbols in code but use ~org-annotation-code~ to describe longer function flows or logic in python.

* Ideas
This package is work in progress. Ideally, it should leverage with emacs bookmarks when annotations are to a specific symbol, where the bookmark points to the orgmode annotation.
