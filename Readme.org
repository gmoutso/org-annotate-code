* Description
~org-annotate-code~ allows you to annotate files in a separate org-mode file. The annotations created are nested headings with the annotation at the deepest node. By default, the first level is the filename and the second is the line number where the annotation is made. However, other annotations are possible according to the annotator that is used. For instance, the second level can be a word in the file at a given position, see ~org-annotate-word~, or for python files the second level can be the python function name where the annotation was made, see ~org-annotate-python~.  The headlines of the trees in the org-file can be changed, and each heading in the annotation is identified by its ~CUSTOM_ID~. In the annotation file, you can visit the annotated file by ~C-c C-o~ on the annotation's heading. Conversely, if you trigger to re-annotate the same section in the file, you will be adding to the already created heading.

The main way to annotate is by using org-mode's capture function. This package defines at the highest level some capture finding functions that are used in ~org-capture~templates~. 
Locally for each file you can specify:
 - in which file the annotations are stored
 - if there is a custom top-level heading always inserted
 - which annotator is used with the generic capure function
You can also specify which annotator to be used by default for each major-mode. If neither a local file annotator is defined nor a major-mode associated annotater, the default annotator will be used. 
* Use
To start using, simply load it
#+begin_src 
(add-to-list 'load-path "~/path/to/org-annotate-code")
(require 'org-annotate-code)
#+end_src
The annotation can be made using a capture template with the function ~org-annotate-code-capture-finding-location~
#+begin_src 
("a" "Annotate" plain #'org-annotate-code-capture-finding-location "%?")
#+end_src
Without further configuration, org-capture will use the default annotator.

There are annotators for specific modes. For instance, to annotate python files
#+begin_src 
(require 'org-annotate-python)
#+end_src
This will associate all python files with this annotator when you use the generic capture function above. The capture mode will then make specific links for python, where the first level is the filename in dotted form and the second and deeper levels are nested headings with python function/class/variable names. Registering for a major mode is done by modifying the alist ~org-annotate-code-info-alist~, eg
#+begin_src 
(add-to-list 'org-annotate-code-info-alist (cons 'python-mode 'org-annotate-python-info-at-point))
#+end_src
will annotate python files with the python annotator. This association is already made when you load ~org-annotate-python~. Not all annotators will register with modes like this. 

If you want to use word annotations by default then
#+begin_src 
(setq org-annotate-code-info-default 'org-annotate-word-info-at-point)
#+end_src
will make annotations that point to the word at the position in the file. This annotator defines a new link of type "word". Functions such as ~org-annotate-python-info-at-point~ or ~org-annotate-word-info-at-point~ are at the core of what is an annotator. You can also override the default annotator in ~org-annotate-code-info-default~ with the local variable ~org-annotate-code-info-override~. For this, you will need to know the annotator's function name, eg in a given buffer
#+begin_src 
(setq org-annotate-code-info-override 'org-annotate-word-info-at-point)
#+end_src
this becomes a local buffer variable. Setting dir-locals.el can make use of different annotators per file.

Alternatively, you can remove python from the alist above and use a separate special template for python in the ~org-capture~templates~, eg
#+begin_src 
("p" "Python" plain #'org-annotate-python-capture-finding-location "%?")
#+end_src
For this, you will need to know the name of the capture finding location. For each annotator there is  one annotator function that can be used with the generic capure finding function and one special capture finding location (which simply wraps the generic function with the override variable).

One can insert a top-level heading, either globally or per file, by setting ~org-annotate-code-heading0~. Beyond this level, typically the top-level heading is the filename, but ultimately this depends on the annotator used. One can also customize the annotation file locally by setting ~org-annotation-code-org-file~. So for instance, each project can save annotations under a different top-level heading in the same file, or in separate files per project, or any combination defined in dir-locals.el.

An annotator that annotates the word at point is defined in ~org-annotate-word~. This creates links that point to a word at a position in a file, and by default clicking on the link takes one to the nearest word at that position. If the minor mode ~org-annotate-live-mode~ is loaded while the annotated file is edited, it will change the ~CUSTOM_ID~ so that the positions are corrected. This is work in progress.

There can be arbitrary nodes of the annotation tree. The annotator functions return a list of nodes and each node is a plist with keys ~:id~ and ~:heading~ and possibly ~:properties~. The top-level heading is inserted after these annotators have done their work. 

Once the annotation is created, the custom id links should not be changed but the headings can change at will. The whole tree can be moved and/or demoted somewhere else in the annotation file. If an annotation at the same place is triggered, there are two options to search for the annotation tree: 
 - a bottom-top search that places importance on the last custom id to exist
 - a top-bottom search that places importance on the whole hierarchy of custom ids to exist
Either the moved entry is found by its id or a new hierarchy of items will be created where the search fails. To customize which of these two methods is used, see  ~org-annotate-code-search-annotation-method~.  

* Annotators
** Line numbers
Creates a tree structure like ~file name -> line number~. This can be achieved out of the box with org-mode.
** python
An annotation might look like the nested headings ~file name -> function definition -> local variable~ or ~filename -> global variable~.  Links are possible by defining a new link type called pydef, eg ~[[pydef:filename.py::newfun.newsubfun.localvariable]]~. 

When creating an annotation, the user can select what is to be annotated, eg ~newfun~, ~newfun.newsubfun~ or ~newfun.newsubfun.localvariable~. If the user chooses to annotate ~newfun.newsubfun~ then  the annotation will have hierarchy ~filename.py -> newfun -> newfun.newsubfun~. One can customize these settings by changing ~org-annotate-python-squash-annotation-level~ and ~org-annotate-python-squash-candidates-level~. 

It is possible to use relative path headings using projectile. Filename headings are dotted by default as in python modules.

** dired
Use ~org-annotate-code-info-at-point-dired~.
Allows to annotate the file at point in dired. The annotations will still be in ~org-annotate-code-org-file~ and under the top-level heading if set.
** word
This creates a link like ~[[word:filename::position::word]]~ that searches for the word near a line number in a file. 

This annotator will keep track of line numbers changes if the text is changed while ~org-annotate-live-mode~ is loaded. It will change the org-file accordingly each time
 - The file is saved
 - The user calls ~org-annotate-live-sync-register~
 - A new annotation is made
However, if you use the live mode, currently, link ids will be renamed to stale if the file changed while ~org-annotate-live-mode~ was not loaded. The live mode is still experimental.

You can also checkout [[https://github.com/bastibe/annotate.el][annotation-mode]], a maturer project, for live changing the line numbers as text is edited.
** index
Use ~org-annotate-code-info-at-point-index~. 
Allows adding the file name, either the current buffer or the file pointed at in dired, in an ~index.org~ file in the /same/ directory as the file. That is ~org-annotate-code-org-file~ or the top-level heading is not used here. This does not register an annotator with the ~org-annotate-code-info-alist~. One would add ~org-annotate-index-capture-finding-location~ in a sepratate capure template, as in
#+begin_src 
("i" "Insert file to index" plain #'org-annotate-index-capture-finding-location "%?")
#+end_src
* Similar Packages
If you know of similar packages, please let me know
 - ~org-annotate-file~ is similar, but ~org-annotate-code~ is presently configurable
 - [[https://github.com/bastibe/annotate.el][annotation-mode]] is a useful package that annotates non-destructively files.
